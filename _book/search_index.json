[["Trend.html", "Chapter 10 Abundance trends 10.1 Linear model 10.2 Exponential growth model 10.3 Exercises", " Chapter 10 Abundance trends In Chapter 5, we examined three approaches for estimating absolute abundance. Those approaches are well suited for small populations that can be readily sampled. For larger populations, it is much more common to estimate relative abundance. The general approach for monitoring relative abundance is to conduct a survey using consistent methods over time, using a gear such as electrofishing, traps, or nets. It is assumed that trends in survey catch reflect trends in abundance. Said another way, we are assuming that catches (on average) are directly proportional to abundance. Trends in abundance from a well-designed survey are valuable whether trying to restore a fish at low abundance or determining whether management of an exploited population is effective. There are several important aspects to planning a survey for monitoring relative abundance. Presumably the focus is on annual trends, so one decision would be how many years would be required before a trend could be detected. The survey catch rate for each year would need to be sufficiently precise to allow for trend detection. Related to these logistical considerations is the decision of what magnitude of change we seek to detect. More gradual changes require much higher precision than if we only seek to detect large increases or decreases. We begin with the simplest case of whether there is a linear trend in relative abundance. This is a Bayesian version of the simple linear regression analysis of traditional statistics courses. Then we consider a more advanced model intended to capture the underlying population dynamics. 10.1 Linear model We begin with the simulation code for generating absolute abundance, which is unknown, and relative abundance as estimated by the survey. Variables that describe the data set and survey process include the length of the time series (n.years), mean population growth rate (mean.lambda), and the standard deviation for the annual growth rate (sigma.lambda). We use a 10-year survey data set, which seems relatively short for a trend analysis but would also be a daunting task if starting up a new survey. The starting absolute population size (10,000) is arbitrary and not estimable, but we can examine trends in relative abundance from the annual catches. Following Kéry and Schaub (2011) (their Section 5.2), population change is modeled assuming exponential growth. A value just above 1 (1.02) for the mean population growth rate provides for a modest rate of population increase, on average. The standard deviation introduces stochasticity in the annual changes, as could occur due to variation in fishing effort or environmental factors. The expected survey catch is the product of population size and the capture probability, or fraction of the population caught by our annual “unit” of survey effort. We use a default capture probability of 0.025. Observation error for the survey catches allows for normally-distributed random variation about the expected catch. rm(list=ls()) # Clear Environment # Generation of simulated data n.years &lt;- 10 N1 &lt;- 10000 # Initial population size mean.lambda &lt;- 1.02 # Mean annual population growth rate sigma.lambda &lt;- 0.02 # Process (temporal) variation in the growth rate (SD) p.survey &lt;- 0.025 # Default capture probability for survey sigma.obs &lt;- 40 # Observation error for survey catch (SD) C &lt;- N &lt;- numeric(n.years) N[1] &lt;- N1 lambda &lt;- rnorm(n.years-1, mean.lambda, sigma.lambda) # Lambda is vector of annual population growth rates for (y in 1:(n.years-1)){ N[y+1] &lt;- N[y] * lambda[y] } C &lt;- rnorm(n=n.years, mean=p.survey*N, sd=sigma.obs) plot(C, ylab=&quot;Survey Catch&quot;, xlab=&quot;Year&quot;) Run the simulation code several times to gain insight into the level of variation possible in a ten-year pattern. Then vary survey length, mean population growth rate and temporal variation, capture probability, and observation error to understand how each setting contributes to the survey pattern of relative abundance. The JAGS code treats the annual survey catches as independent observations, and estimates an intercept (\\(b_1\\)) and slope (\\(b_2\\)) for the linear regression model relating year to the relative abundance data. A third parameter (sigma.est) accounts for variation in the survey catch around the line, which would be due not only to observation error but also annual variation in population growth. Uninformative prior distributions are used for the three parameters. The initial value for the slope is set at 0, and the initial value for the intercept varies between the minimum and maximum observed annual catch. # Load necessary library library(rjags) library(R2jags) # JAGS code for estimating model parameters sink(&quot;PopTrend_Linear.txt&quot;) cat(&quot; model { # Priors for (i in 1:2){ b[i] ~ dnorm(0, 0.0001) } sigma.est ~ dunif(0, 100) tau &lt;- pow(sigma.est, -2) # Likelihood for (y in 1:n.years){ ExpC[y] &lt;- b[1] + b[2]*y C[y] ~ dnorm(ExpC[y], tau) } #y p.pos &lt;- step(b[2]) } &quot;,fill = TRUE) sink() # Bundle data jags.data &lt;- list(&quot;n.years&quot;, &quot;C&quot;) # Initial values. jags.inits &lt;- function(){ list(b=c(runif(n=1, min=min(C), max=max(C)), 0), sigma.est=runif(n=1, min=0, max=100) )} model.file &lt;- &#39;PopTrend_Linear.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;b&quot;, &quot;sigma.est&quot;, &quot;p.pos&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 5000, model.file) print(jagsfit) #plot(jagsfit) year.seq &lt;- seq(1:n.years) C.hat &lt;- jagsfit$BUGSoutput$mean$b[1]+jagsfit$BUGSoutput$mean$b[2]*year.seq points(year.seq, C.hat, type=&quot;l&quot;, col=&quot;red&quot;) For convenience in viewing the results, we skip plotting the jagsfit object and simply add the regression line to the original plot of survey catches (Figure 10.1). We can examine the credible interval for \\(b_2\\) to determine whether the survey provides evidence of a trend (credible interval not including 0). A more quantitative approach is to estimate the probability of a positive mean growth rate (Pregler et al. 2019). We can use the step() function (which is 1 for an argument &gt; 0; 0 otherwise) to calculate the fraction of retained slope estimates that are greater than 0 (mean for calculated variable p.pos). FIGURE 10.1: Example of fitted linear model for survey catch versus year. Try running the simulation and analysis code multiple times and see whether your visual interpretation of the pattern (or lack thereof) matches with the regression results. Then vary the simulation settings to see the level of support for a positive trend. For example, the probability of a positive mean growth rate was 0.80, 0.96, 0.84, 0.50, and 1.00 for five trials using the default settings, compared to 0.99, 0.57, 0.94, 0.98, and 0.97 if observation error was reduced by half. 10.2 Exponential growth model An exponential growth model was used in Section 10.1 to simulate population change, but our analysis ignored the dependence between the annual survey catches. An improved approach would be to fit a model that attempts to reveal the underlying population dynamics. The simulation code is unchanged, but the JAGS code now specifies exponential growth. Our predicted survey catches have the same growth parameters as the underlying population, because of the assumed direct proportionality between catch and absolute abundance. Following Kéry and Schaub (2011) (their Section 5.4), we fit the exponential growth model on the log scale. JH NOTE: ** confirm and provide rationale for ln-scale fit. Fitting an underlying population model makes it possible to distinguish between the two sources of variation in survey catch: variation in population growth rate and survey sampling. The former is referred to as process error (Kéry and Schaub 2011), as it is variation in the biological process (population growth). The latter is observation error, or random variation in the survey catch (our proxy for annual abundance). The JAGS code now has parameters for initial relative abundance (predicted ln-scale catch in year 1), the mean and standard deviation for the annual sequence of population growth rates, and the standard deviation for observation error. The parameters for population growth rate are hyperparameters, describing a normal distribution for the annual growth rates. Population growth in ln-scale uses the model \\(lnN_{t+1}=lnN_t+r\\), so 1+r provides a value comparable to mean.lambda in the simulation code. Uninformative prior distributions are used for all parameters. # Load necessary library library(rjags) library(R2jags) # JAGS code for estimating model parameters sink(&quot;PopTrend_ExpGr.txt&quot;) cat(&quot; model { # Priors logC.est[1] ~ dunif(1, 100) # Initial relative abundance mean.r.est ~ dnorm(0, 0.001) # Mean growth rate sigma.proc.est ~ dunif(0, 1) # Process error (annual variation in r) tau.proc.est &lt;- pow(sigma.proc.est, -2) sigma.obs.est ~ dunif(0, 100) # Observation error tau.obs.est &lt;- pow(sigma.obs.est, -2) # Likelihood for (y in 1:(n.years-1)){ r[y] ~ dnorm(mean.r.est, tau.proc.est) logC.est[y+1] &lt;- logC.est[y] + r[y] } #y for (y in 1:n.years) { C.est[y] &lt;- exp(logC.est[y]) C[y] ~ dnorm(C.est[y], tau.obs.est) } #y p.pos &lt;- step(mean.r.est) } &quot;,fill = TRUE) sink() # Bundle data jags.data &lt;- list(&quot;n.years&quot;, &quot;C&quot;) # Initial values. jags.inits &lt;- function(){list(sigma.proc.est = runif(n=1, min=0, max=1), mean.r.est = rnorm(n=1, mean=0, sd=1), sigma.obs.est = runif(n=1, min=0, max=100), logC.est = c(runif(n=1, min=5, max=10), rep(NA,(n.years-1))))} model.file &lt;- &#39;PopTrend_ExpGr.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;mean.r.est&quot;, &quot;sigma.proc.est&quot;, &quot;sigma.obs.est&quot;, &quot;C.est&quot;, &quot;p.pos&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 20000, model.file) print(jagsfit) #plot(jagsfit) year.seq &lt;- seq(1:n.years) points(year.seq, jagsfit$BUGSoutput$mean$C.est, type=&quot;l&quot;, col=&quot;red&quot;) This is a much more complex model than the linear regression, and we increase the number of iterations to achieve convergence (which should be confirmed by checking Rhat values). The predicted catches are now not a straight line because we are estimating annual values for population growth rate (Figure 10.2). The smoothed pattern for predicted catches is the model’s attempt to describe the biological process (exponential growth with year-to-year variation in growth rate). Variation in observed catches about the fitted line reflects estimated observation error. Try several runs using a small value for observation error to see that the model can closely mimic the population trajectory when observation error is low. It can also be instructive to try an extreme value for the length of the time series. The annual estimates of population growth rate are drawn from a shared normal distribution, so a longer time series helps in sorting out process versus observation error (e.g., try n.years=40, sigma.lambda=0.05, and sigma.obs=10). FIGURE 10.2: Example of fitted exponential growth model for survey catch versus year. We use the step() function (calculated parameter p.pos) to estimate the probability that the mean population growth rate is positive. We obtained probabilities of 0.73, 0.73, 0.40, 0.44, and 0.61 for five trials using the default settings, compared to 0.74, 0.69, 0.92, 0.99, and 0.91 for a simulation mean growth rate of 1.05. These results show the challenge in detecting a population trend, which will depend on the magnitude and annual variation in the mean annual change, the length of the time series, and the precision of the survey. 10.2.1 Forecasting In Section 10.2, we fitted an exponential growth model to describe underlying population dynamics. One advantage of that approach is that we can use that underlying model to project future population levels. We add a new simulation setting (p.years) for the number of future years to predict abundance, and generate n.years+p.years values for population size (N). The catch vector has n.years of observed survey catches, augmented by p.years of NA values. The code for plotting catch is moved below the JAGS section, because now we need to choose a range for the y-axis that will accommodate the observed and predicted catches plus the (generally wider) credible intervals. rm(list=ls()) # Clear Environment # Generation of simulated data p.years &lt;- 5 # Predicted future population levels n.years &lt;- 10 # Years of survey data N1 &lt;- 10000 # Initial population size mean.lambda &lt;- 1.02 # Mean annual population growth rate sigma.lambda &lt;- 0.02 # Process (temporal) variation in the growth rate (SD) p.survey &lt;- 0.025 # Default capture probability for survey sigma.obs &lt;- 40 # Observation error for survey catch (SD) C &lt;- N &lt;- numeric(n.years+p.years) N[1] &lt;- N1 lambda &lt;- rnorm((n.years+p.years-1), mean.lambda, sigma.lambda) # Draw vector of annual growth rates for (y in 1:(n.years+p.years-1)){ N[y+1] &lt;- N[y] * lambda[y] } C &lt;- rnorm(n=n.years, mean=p.survey*N, sd=sigma.obs) C &lt;- c(C, rep(NA, p.years)) # Observed survey catches augmented by NA values The likelihood in the JAGS code is modified slightly to accommodate the p.years of additional (missing) catches. We also add a step() function to estimate p.increase, the probability that predicted catch in the final year is higher than in year one. This is an arbitrary choice, but provides some insight into whether a detectable increase is expected over the modeled time horizon. Data passed to JAGS now includes p.years, and we modify the length of the vector of initial values for predicted catch. # Load necessary library library(rjags) library(R2jags) # JAGS code for estimating model parameters sink(&quot;PopTrend_ExpGr.txt&quot;) cat(&quot; model { # Priors logC.est[1] ~ dunif(1, 100) # Initial relative abundance mean.r.est ~ dnorm(0, 0.001) # Mean growth rate sigma.proc.est ~ dunif(0, 1) # Annual variation in r tau.proc.est &lt;- pow(sigma.proc.est, -2) sigma.obs.est ~ dunif(0, 100) # Observation error tau.obs.est &lt;- pow(sigma.obs.est, -2) # Likelihood for (y in 1:(n.years+p.years-1)){ r[y] ~ dnorm(mean.r.est, tau.proc.est) logC.est[y+1] &lt;- logC.est[y] + r[y] } #y for (y in 1:(n.years+p.years)) { C.est[y] &lt;- exp(logC.est[y]) C[y] ~ dnorm(C.est[y], tau.obs.est) } #y p.pos &lt;- step(mean.r.est) p.increase &lt;- step(C.est[n.years+p.years]-C.est[1]) # Prob of increase from first to last } &quot;,fill = TRUE) sink() # Bundle data jags.data &lt;- list(&quot;n.years&quot;, &quot;p.years&quot;, &quot;C&quot;) # Initial values. jags.inits &lt;- function(){list(sigma.proc.est = runif(n=1, min=0, max=1), mean.r.est = rnorm(n=1, mean=0, sd=1), sigma.obs.est = runif(n=1, min=0, max=100), logC.est = c(runif(n=1, min=5, max=10), rep(NA, (n.years+p.years-1))))} model.file &lt;- &#39;PopTrend_ExpGr.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;mean.r.est&quot;, &quot;sigma.proc.est&quot;, &quot;sigma.obs.est&quot;, &quot;C.est&quot;, &quot;p.pos&quot;, &quot;p.increase&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 40000, model.file) print(jagsfit) plot(jagsfit) Convergence was slower for this model compared to Section 10.2, so the number of iterations was increased to 40,000. Plotting the jagsfit object shows that uncertainty about predicted catch increases sharply over the forecast years. The future forecasts use annual population growth rates that are drawn randomly from the normal distribution. This makes clear how little can be said about population size or trends, even a couple of years into the future. We can now plot the observed catches, augmented by the predicted catch vector and lines representing lower and upper 95% credible intervals (Kéry and Schaub 2011). The quantile() function provides the 0.025 and 0.975 quantiles from the vector of retained MCMC updates (draws from the posterior distribution). The ylim plot option allows us to scale the y-axis to accommodate all four series. par(mfcol=c(1,1)) # Return to default of 1 panel year.seq &lt;- seq(1:length(C)) lower &lt;- upper &lt;- length(C) for (y in 1:length(C)){ lower[y] &lt;- quantile(jagsfit$BUGSoutput$sims.list$C.est[,y], 0.025) upper[y] &lt;- quantile(jagsfit$BUGSoutput$sims.list$C.est[,y], 0.975) } #y min.y &lt;- min(C[1:n.years],jagsfit$BUGSoutput$mean$C.est, lower) max.y &lt;- max(C[1:n.years],jagsfit$BUGSoutput$mean$C.est, upper) plot(year.seq, C, ylab=&quot;Survey Catch&quot;, xlab=&quot;Year&quot;, ylim = c(min.y, max.y)) points(year.seq, jagsfit$BUGSoutput$mean$C.est, type=&quot;l&quot;, col=&quot;red&quot;) points(year.seq, lower, type=&quot;l&quot;, lty=&quot;dashed&quot;) points(year.seq, upper, type=&quot;l&quot;, lty=&quot;dashed&quot;) The observed catches should generally fall within the 95% credible intervals (Figure 10.3). As in Section 10.2, the red line for predicted catch has a smoother trajectory than the individual catches. How many years into the future would you be confident in predicting the population trend? FIGURE 10.3: Example of fitted exponential growth model for survey catch versus year with forecasts for five additional years. Dashed lines represent lower and upper 95% credible intervals. 10.3 Exercises For the linear model (Section 10.1), compare the probability of a positive mean growth rate (p.pos) for sigma.lambda=0.02 (default) and 0.01, using ten simulation trials at each level. For the exponential growth model (Section 10.2), use simulation to determine the approximate level for observation error where p.pos would typically (e.g., 8 of 10) exceed 90%. For the exponential growth model that includes forecasting (Section 10.2.1), compare a sequence of estimates for p.increase (probability that predicted catch in final year exceeds year one) for mean population growth rates of 1.02 and 1.05. References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
