[["real-data-examples.html", "A Real-data examples A.1 Abundance: Removal A.2 Abundance: Mark-recapture A.3 Survival: Age-composition A.4 Survival: Tag-based A.5 Growth: age-length A.6 Recruitment: Beverton-Holt curve", " A Real-data examples The purpose of this appendix is to show, for a subset of models, the process of model fitting to real values rather than simulated data. Removing the simulation code generally shortens and simplifies the examples. I have included brief comments regarding necessary code modifications. Reported point estimates are medians, which provide a better measure of central tendency when posterior distributions are skewed (Kruschke 2021). A.1 Abundance: Removal The removal method (Section 5.1) is used to estimate abundance in a closed study area, based on a sequence of catches. Otis et al. (1978) provided an example for whitefish (Coregonus clupeaformis) in Shakespeare Island Lake, based on gill netting for seven successive weeks (original data from Ricker 1958). No changes were needed in the R or JAGS code other than replacing the simulation code with the the vector of observed catches and changing the number of removal samples. rm(list=ls()) # Clear Environment # Removal study - whitefish (Ricker 1958) Catch &lt;- c(25, 26, 15, 13, 12, 13, 5) N.removals &lt;- length(Catch) # Number of removals # Load necessary library packages library(rjags) # Package for fitting JAGS models from within R library(R2jags) # Package for fitting JAGS models. Requires rjags # JAGS code for fitting model sink(&quot;RemovalModel.txt&quot;) cat(&quot; model{ # Priors CapProb.est ~ dunif(0,1) N.est ~ dunif(TotalCatch, 2000) N.remaining[1] &lt;- trunc(N.est) for(j in 1:N.removals){ Catch[j]~dbin(CapProb.est, N.remaining[j]) # jth removal N.remaining[j+1] &lt;- N.remaining[j]-Catch[j] } #j } &quot;,fill=TRUE) sink() # Bundle data TotalCatch &lt;- sum(Catch[]) jags.data &lt;- list(&quot;Catch&quot;, &quot;N.removals&quot;, &quot;TotalCatch&quot;) # Initial values jags.inits &lt;- function(){ list(CapProb.est=runif(1, min=0, max=1), N.est=runif(n=1, min=TotalCatch, max=2000))} model.file &lt;- &#39;RemovalModel.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;N.est&quot;, &quot;CapProb.est&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin = 1, n.iter = 40000, model.file) print(jagsfit) plot(jagsfit) The analysis by Otis et al. (1978) using program CAPTURE indicated that a constant capture probability model was appropriate. Their estimate (\\(\\hat{N}\\)=138.07) was similar to the median estimate I obtained using Bayesian methods (144.4). Their symmetrical 95% confidence interval (109-167) was more narrow than the 95% credible interval I obtained using Bayesian methods (121.8-225.3), due to the right-skew of the posterior distribution for N.est (e.g., try hist(jagsfit$BUGSoutput$sims.list$N.est)). A.2 Abundance: Mark-recapture Ogle (2016) analyzed a two-sample mark-recapture experiment for walleye larger than 304 mm (Sander vitreus). No changes in the R or JAGS code were required other than replacing the Section 5.2 simulation code with observed values. rm(list=ls()) # Clear Environment # Ogle (2016) # Wisconsin Department of Natural Resources # Mark-recapture walleye &gt; 304 mm n1 &lt;- 2555 # First sample (Marked) n2 &lt;- 274 # Second sample m2 &lt;- 92 # Marked fish in second sample # Load necessary library packages library(rjags) # Package for fitting JAGS models from within R library(R2jags) # Package for fitting JAGS models. Requires rjags # JAGS code sink(&quot;TwoSampleCR.txt&quot;) cat(&quot; model { # Priors MarkedFraction ~ dunif(0, 1) # Calculated value N.hat &lt;- n1 /MarkedFraction # Likelihood # Binomial distribution for observed recaptures m2 ~ dbin(MarkedFraction, n2) } &quot;,fill = TRUE) sink() # Bundle data jags.data &lt;- list(&quot;n1&quot;, &quot;n2&quot;, &quot;m2&quot;) # Initial values. jags.inits &lt;- function(){ list(MarkedFraction=runif(1, min=0, max=1))} model.file &lt;- &#39;TwoSampleCR.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;N.hat&quot;, &quot;MarkedFraction&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, inits=jags.inits, jags.params, n.chains = 3, n.thin = 1, n.iter = 2000, n.burnin = 1000, model.file) print(jagsfit, digits=3) plot(jagsfit) Results using Bayesian methods (N.est median=7569.6, 95% credible interval 6515.7-9015.2) were similar to estimates provided by Ogle (2016) using the Chapman (1951) estimator (\\(\\hat{N}\\)=7557, 95% confidence interval 6454-8973). A.3 Survival: Age-composition Section 6.1 showed an approach for estimating survival using age composition data. Here I illustrate a different approach: a Bayesian version of a traditional catch curve analysis. Quinn and Deriso (1999) provided a catch curve analysis for Pacific halibut in the northeastern Pacific Ocean, using fishery catch data for the 1960 year class between ages 10 and 20 (i.e., tracking a single cohort across multiple years). Unlike the approach in Section 6.1, a traditional catch curve analysis uses ln-transformed catches, for the following reason. The equation for population size at time t (Section 7.2) is \\(N_t = N_0 * exp(-Z*t)\\). Multiplying both sides by a time-independent exploitation rate \\(\\mu\\) produces \\(\\mu*N_t = \\mu*N_0 * exp(-Z*t)\\) or \\(C_t = \\mu*N_0 * exp(-Z*t)\\) (Quinn and Deriso 1999). Log-transforming that equation produces \\(ln(C_t) = ln(\\mu * N_0) -Z*t\\), which is a linear regression equation with intercept \\(ln(\\mu*N_0)\\) and slope -Z. Fitting the model to log-transformed catches implies that the catch data are considered to be lognormally distributed (Quinn and Deriso 1999). The Bayesian code uses coded ages 1-10 rather than true ages 10-20 and fits the linear regression model using the dnorm() function for the likelihood. Estimated survival is obtained as \\(exp(-Z)\\) and as always the MCMC process provides a complete characterization of that calculated parameter. rm(list=ls()) # Clear Environment # Estimating survival using fishery catch data # Pacific halibut, ages 10-20 (1960 year class) # Quinn and Deriso 1999 Catch &lt;- c(179187, 122785, 89241, 58111, 26682, 23339, 14668, 10050, 5866, 3121, 4837) lnC &lt;- log(Catch) # ln-transform to fit traditional catch curve Age &lt;- 10:20 # True ages for plotting MaxCode &lt;- length(Catch) CodedAge &lt;- 1:MaxCode # Coded ages for fitting model #----------------------------------------------- # Fit ln-scale model # Load necessary library packages library(rjags) library(R2jags) # JAGS code sink(&quot;CatchCurve.txt&quot;) cat(&quot; model{ # Priors Z.est ~ dunif(0, 2) # Instantaneous total mortality rate lnC.intercept ~ dunif(0, 20) Var.est ~ dunif(0, 20) tau &lt;- 1/Var.est # Precision sd.est &lt;- sqrt(Var.est) S.est &lt;- exp(-Z.est) # Likelihood for (a in 1:MaxCode){ lnC.hat[a] &lt;- lnC.intercept - (Z.est*a) lnC[a] ~ dnorm(lnC.hat[a], tau) } # a } &quot;,fill=TRUE) sink() # Bundle data jags.data &lt;- list(&quot;lnC&quot;, &quot;MaxCode&quot;) # Initial values jags.inits &lt;- function(){ list(Z.est=runif(n=1, min=0, max=2), lnC.intercept=runif(n=1, min=0, max=20), Var.est=runif(n=1, min=0, max=20))} model.file &lt;- &#39;CatchCurve.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;S.est&quot;, &quot;Z.est&quot;, &quot;lnC.intercept&quot;, &quot;sd.est&quot;, &quot;lnC.hat&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 4000, n.burnin=2000, model.file) print(jagsfit) plot(jagsfit) y.bounds &lt;- range(lnC, jagsfit$BUGSout$median$lnC.hat) plot(Age, lnC, ylim=y.bounds, xlab=&quot;Age&quot;, ylab=&quot;ln-Catch&quot;) points(Age, jagsfit$BUGSout$median$lnC.hat, type=&quot;l&quot;, col=&quot;red&quot;) Quinn and Deriso (1999) reported an estimated Z of 0.409 with a 95% confidence interval of 0.359-0.459; our Bayesian median estimate was 0.412, with 95% credible interval of 0.353-0.469. Quinn and Deriso (1999) estimated survival to be 0.664, with 95% confidence interval of 0.632-0.698. The Bayesian median estimate was 0.663, with 95% credible interval 0.626-0.703. This is yet another example where Bayesian results using uninformative priors are very similar to frequentist results. The last three lines of R code show the ln-transformed catches and fitted curve. The plot is essentially identical to that shown by Quinn and Deriso (1999). The ln-transformed catches are well described by the fitted curve, suggesting that the assumptions of a catch curve analysis are reasonable for the period of analysis. A.4 Survival: Tag-based Section 6.3 showed an approach for estimating survival rate using a multi-period tag-return study. Here I have replaced the simulation code with a male wood duck (Aix sponsa) band-recovery matrix (Table 2.2, Brownie et al. 1985). The band recovery values are entered as a vector, then transformed using an upper diagonal matrix using the matrix() function. Variables were renamed to be more consistent with the band-recovery experiment. The main change to the R code was that banded wood ducks were released for three years (1964-1966) but bands were recovered for five years (1964-1968). This required separate variables for the number of release (RelYears) and recovery years (RecYears), unlike the 3X3 example from Section 6.3. Brownie et al. (1985) fitted a model with time-dependent survival and tag-recovery rates but here I estimated time-independent survival and tag-recovery rates for consistency with Section 6.3. The only changes required for the JAGS code were because of the different number of years for release and recovery. rm(list=ls()) # Clear Environment # Recovered bands of adult male wood ducks # Brownie et al. (1985) RelYears &lt;- 3 # 1964-1966 # Release years RecYears &lt;- 5 # 1964-1968 # Recovery years R &lt;- c(1603, 1595, 1157) # Releases by year Recoveries &lt;- c(127, 44, 37, 40, 17, NA, NA, 62, 76, 44, 28, NA, NA, NA, 82, 61, 24, NA) # Convert vector of band recoveries into upper diagonal # matrix, NA added for final column for bands not seen again Rec.Mat &lt;- matrix(Recoveries,nrow = RelYears,ncol = (RecYears+1), byrow=TRUE) # Placeholder NA - replace by number of bands not seen again for (y in 1:RelYears){ Rec.Mat[y,RecYears+1] &lt;- R[y]-sum(Rec.Mat[y,y:RecYears]) } #y # Load necessary library packages library(rjags) library(R2jags) # Specify model in JAGS sink(&quot;TagReturn.txt&quot;) cat(&quot; model { # Priors S.est ~ dunif(0,1) # Time-independent survival rate r.est ~ dunif(0,1) # Time-independent tag-recovery rate # Calculated value A.est &lt;- 1-S.est # Rate of mortality # Cell probabilities for (i in 1:RelYears) { p.est[i,i] &lt;- r.est for (j in (i+1):RecYears) { p.est[i,j] &lt;- p.est[i,(j-1)] * S.est } #j p.est[i,RecYears+1] &lt;- 1 - sum(p.est[i, i:RecYears]) # Last column is prob of not being seen again } #i # Likelihood for (i in 1:RelYears) { Rec.Mat[i,i:(RecYears+1)] ~ dmulti(p.est[i,i:(RecYears+1)], R[i]) }#i } # model &quot;,fill=TRUE) sink() # Bundle data jags.data &lt;- list(&quot;Rec.Mat&quot;, &quot;RelYears&quot;, &quot;RecYears&quot;, &quot;R&quot;) S.init &lt;- runif(1,min=0,max=1) r.init &lt;- 1-S.init # Initialize r relative to S # Initial values jags.inits &lt;- function(){list(S.est = S.init, r.est=r.init)} model.file &lt;- &#39;TagReturn.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;S.est&quot;, &quot;r.est&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 4000, n.burnin=2000, model.file) print(jagsfit) plot(jagsfit) The estimates from the Bayesian analysis (median survival 0.66, 95% credible interval 0.62-0.71; median tag-recovery rate 0.06, 95% credible interval 0.06-0.07) were very similar to maximum-likelihood estimates (mean survival 0.64, 95% confidence interval 0.56-0.71; mean tag-recovery rate 0.06, 95% confidence interval 0.05-0.07) reported by Brownie et al. (1985). A.5 Growth: age-length This example data set for fitting a von Bertalanffy growth curve is for rougheye rockfish (Sebastes aleutianus). The original study was by Nelson and Quinn II (1987); Quinn and Deriso (1999) fitted the model using nonlinear least squares. Using real rather than simulated data usually results in simpler code, but here, the values provided by Quinn and Deriso (1999) were age-specific sample sizes, averages, and standard deviations. A curve could be fitted to age-specific averages but that gives equal weight to each age, whereas age-specific sample sizes actually varied widely (range from 1 to 31). To approximate the original data set of individual fish age and length observations, I looped over the sample size by age and generated “observed” values using the rnorm() function. Working with individual observations retains the variation in the original length data set. Note that the “observed” data set will vary from run to run so it is helpful to run the code multiple times. The JAGS code was unchanged from the example in Section 8.1. # Fitting von Bertalanffy curve # Rougheye rockfish # Nelson, B., and T. J. Quinn II. 1987. Population parameters for # rougheye rockfish (Sebastes aleutianus). Proc. Int. Rockfish # Symp., Alaska Sea Grant Rep. 87-2:209-228. rm(list=ls()) # Clear Environment AgeClass &lt;- c(2:38, 40:47, 49, 50, 52:68, 70, 72,75, 77, 80, 82, 85, 95) ave.Len &lt;- c(18, 14.5, 17.9, 20.6, 21.9, 23.4, 25.2, 27.2, 29.6, 30.7, 32.4, 33, 32.8, 35, 36.3, 37.2, 36.2, 38.8, 37.7, 40.6, 40.9, 38.9, 40, 41.9, 42.7, 42.6, 45.5, 40.9, 44.6, 46.6, 44.9, 47.2, 48.3, 45.4, 48.8, 46.5, 46.5, 47.9, 49.3, 48, 49, 50, 51.3, 52, 48.9, 48.7, 48.6, 51.5, 52, 50, 52.7, 59, 52, 50, 50, 51, 50, 52, 50, 59, 55, 52.5, 50, 54, 59.5, 51, 51, 60, 74, 49, 57, 60.5) sd.Len &lt;- c(NA, 4.9, 2.2, 2.1, 2.1, 2.3, 2.5, 2, 3, 2.9, 3.7, 2.3, 2.9, 4.1, 2.4, 5.1, 4.4, 1.8, 5.4, 3.1, 4.3, 4.6, 2.4, 3.9, 5.5, 6.4, 4, 4.6, 4.4, 3.6, 6.3, 4.6, 5.1, 4.5, 3.4, 4, 2.5, 4.9, 2.5, 2.1, 2.0, 2.2, 5.9, NA, 2.7, 2.5, 2.8, 0.7, 11.4, NA, 8, NA, 3.9, NA, NA, 1.4, NA, 1, NA, 9.9, 1.4, 2.1, 0, 1, 13.4, 1.4, NA, 12.7, NA, NA, NA, 16.3) n.AgeClass &lt;- c(1,6,19,31,27,20,11,19,12,13,12,4,8,11,7,12,10,5,9,7,14, 14,13,15,15,9,8,8,13,11,9,9,16,13,10,14,4,8,3,7,3,7,10, 1,9,3,7,2,4,1,3,1,5,1,1,4,1,3,1,2,2,2,2,1,2,2,1,2,1,1, 1,2) N.AgeLen &lt;- sum(n.AgeClass[]) Len &lt;- array(data=NA, dim=N.AgeLen) Age &lt;- array(data=NA, dim=N.AgeLen) fish &lt;- 1 # Counter for individual fish for (a in 1:length(AgeClass)){ if (n.AgeClass[a]==1) { Age[fish] &lt;- AgeClass[a] Len[fish] &lt;- ave.Len[a] fish &lt;- fish+1 } else for (j in 1:n.AgeClass[a]){ Age[fish] &lt;- AgeClass[a] Len[fish] &lt;- rnorm(n=1, mean=ave.Len[a], sd=sd.Len[a]) fish &lt;- fish+1 } #j } #a # Load necessary library packages library(rjags) library(R2jags) # JAGS code sink(&quot;GrowthCurve.txt&quot;) cat(&quot; model{ # Priors L_inf.est ~ dunif(0, 200) k.est ~ dunif(0, 2) t0.est ~ dunif(-5, 5) Var_L.est ~ dunif(0,100) # Variability in length at age # Calculated value tau.est &lt;- 1/Var_L.est # Likelihood for (i in 1:N.AgeLen) { Len_hat[i] &lt;- L_inf.est*(1-exp(-k.est*(Age[i]-t0.est))) Len[i] ~ dnorm(Len_hat[i], tau.est) } #i } &quot;,fill=TRUE) sink() # Bundle data jags.data &lt;- list(&quot;N.AgeLen&quot;, &quot;Age&quot;, &quot;Len&quot;) # Initial values jags.inits &lt;- function(){list(L_inf.est=runif(n=1, min=0, max=max(Len)), k.est=runif(n=1, min=0, max=2), t0.est=runif(n=1, min=-5, max=5), Var_L.est=runif(n=1, min=0, max=100))} model.file &lt;- &#39;GrowthCurve.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;L_inf.est&quot;, &quot;k.est&quot;, &quot;t0.est&quot;, &quot;Var_L.est&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 10000, model.file) print(jagsfit) plot(jagsfit) Len_hat &lt;- array(data=NA, dim=N.AgeLen) for (a in 1:N.AgeLen){ Len_hat[a] &lt;- jagsfit$BUGSoutput$median$L_inf.est*(1- exp(-jagsfit$BUGSout$median$k.est *(Age[a]-jagsfit$BUGSout$median$t0.est))) } #a plot(Age, Len, xlab=&quot;Age&quot;, ylab=&quot;Length (cm)&quot;) points(Age, Len_hat, type=&quot;l&quot;, col=&quot;red&quot;) Bayesian median estimates from one run (\\(L_\\infty\\)=53.761, \\(k\\)=0.052, \\(t_0\\)=-4.470) were in reasonable agreement with the least-squares estimates reported by Quinn and Deriso (1999): \\(L_\\infty\\)=54.9, \\(k\\)=0.0441, and \\(t_0\\)=-4.53. The estimated variance of points about the fitted line (Var_L.est=17.910) was similar to the residual mean square reported by Quinn and Deriso (1999) (17.13), suggesting that the simulation approach used here was effective in restoring the variability in individual age:length observations. A.6 Recruitment: Beverton-Holt curve Section 9.1 used a complex age-structured simulation model to produce spawning stock and recruitment values. It is much simpler to use a real data set, as illustrated here for North Sea plaice (Ricker 1975). Spawning stock and recruitment values are paired in Ricker (1975), so no time lag between indices is needed. The only changes from the R and JAGS code used in Section 9.1 were to replace the simulation code with fixed values, remove the time lag in indices, and to use Ricker’s notation for spawning stock (P) and recruitment (R). # Fitting Beverton-Holt stock-recruitment curve # North Sea plaice. Ricker 1975 Table 11.8 # Units arbitrary # Adult stock biomass (P) P &lt;- c(9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 12, 12, 18, 18, 19, 20, 21, 21, 26, 32, 35, 45, 54, 70, 82, 88) R &lt;- c(13, 20, 45, 13, 13, 20, 21, 26, 11, 12, 8, 15, 7, 10, 17, 16, 11, 15, 16, 33, 10, 23, 13, 13, 12, 24) # Load necessary library packages library(rjags) library(R2jags) sink(&quot;StockRecruit.txt&quot;) cat(&quot; model { # Model parameters: Beverton-Holt alpha and beta, # ln-scale variance for fitted curve # Priors BH_alpha.est ~ dunif(0, 10) BH_beta.est ~ dunif(0, 10) V_rec.est ~ dunif(0, 10) tau &lt;- 1/V_rec.est # Likelihood for(y in 1:Y) { lnR_hat[y] &lt;- log(1/(BH_alpha.est+BH_beta.est/P[y])) R[y] ~ dlnorm(lnR_hat[y],tau) R_hat[y] &lt;- exp(lnR_hat[y]) } #y } &quot;,fill=TRUE) sink() # Bundle data Y &lt;- length(P) jags.data &lt;- list(&quot;Y&quot;, &quot;P&quot;, &quot;R&quot;) # Initial values y &lt;- R[1:Y] x &lt;- P[1:Y] nls_init &lt;- nls(y ~ 1/(BH_a_start+BH_b_start/x), start = list(BH_a_start = 0.001, BH_b_start = 0.001), algorithm=&quot;port&quot;, lower=c(1E-6, 0), upper=c(1000,1000)) #summary(nls_init) nls_save &lt;- coef(nls_init) #y_hat &lt;- 1/(nls_save[1]+nls_save[2]/x) #plot(x,y) #points(x,y_hat, col=&quot;red&quot;, type=&quot;l&quot;) jags.inits &lt;- function(){ list(BH_alpha.est=nls_save[1], BH_beta.est=nls_save[2], V_rec.est=runif(n=1, min=0, max=10))} model.file &lt;- &#39;StockRecruit.txt&#39; # Parameters monitored jags.params &lt;- c(&quot;BH_alpha.est&quot;, &quot;BH_beta.est&quot;, &quot;V_rec.est&quot;, &quot;R_hat&quot;) # Call JAGS from R jagsfit &lt;- jags(data=jags.data, jags.params, inits=jags.inits, n.chains = 3, n.thin=1, n.iter = 10000, model.file) print(jagsfit) plot(jagsfit) df.xy &lt;- data.frame(P[1:Y], R[1:Y], jagsfit$BUGSoutput$median$R_hat) df.xy &lt;- df.xy[order(df.xy[,1]),] # Sort by survey index for plotting y.bounds &lt;- range(R[1:Y],jagsfit$BUGSoutput$median$R_hat) plot(df.xy[,1],df.xy[,2], ylab=&quot;Recruitment index&quot;, xlab=&quot;Spawning Stock Index&quot;, ylim=y.bounds) #c(min.y, max.y)) points(df.xy[,1], df.xy[,3], type=&quot;l&quot;) Bayesian estimates of \\(\\alpha\\) (median=0.060, 95% credible interval 0.042-0.075) and \\(\\beta\\) (0.091, 95% CrI 0.003-0.368) were similar to estimates (0.06312; 0.1606) provided by Ricker (1975). References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
